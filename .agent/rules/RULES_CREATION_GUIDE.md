# 📜 글로벌 규칙 생성 가이드 (Rules Creation Guide)

> **목적**: 프로젝트 전반에 적용되는 일관성 있는 규칙 문서를 작성하기 위한 메타 가이드  
> **적용 대상**: 코딩 표준, 협업 규칙, 보안 정책, 아키텍처 원칙 등  
> **업데이트**: 2026-02-01

---

## 🎯 규칙 문서의 목적

프로젝트 규칙은 다음을 달성해야 합니다:

1. **일관성 보장**: 모든 팀원이 동일한 기준으로 작업
2. **의사결정 속도 향상**: 반복되는 질문에 대한 명확한 답변 제공
3. **품질 유지**: 최소 품질 기준선 설정
4. **온보딩 가속화**: 신규 팀원이 빠르게 프로젝트 문화 이해

---

## 📊 규칙의 계층 구조

규칙은 다음 3단계 계층으로 관리됩니다:

```
┌─────────────────────────────────┐
│  Level 0: 철학 (Philosophy)     │  ← 변하지 않는 핵심 가치
├─────────────────────────────────┤
│  Level 1: 원칙 (Principles)     │  ← 의사결정 기준
├─────────────────────────────────┤
│  Level 2: 규칙 (Rules)          │  ← 구체적인 실행 규칙
└─────────────────────────────────┘
```

### Level 0: 철학 (Philosophy)

**특징**: 절대 변하지 않는 핵심 가치

**예시**:

- "사용자 데이터를 절대 유출하지 않는다"
- "모든 팀원의 의견은 동등한 가치를 가진다"
- "빠른 실패, 빠른 학습 (Fail Fast, Learn Fast)"

**문서 위치**: `.agent/philosophy/CORE_VALUES.md`

### Level 1: 원칙 (Principles)

**특징**: 구체적 상황에서 의사결정 기준이 되는 지침

**예시**:

- "보안과 속도가 충돌할 때는 항상 보안 우선"
- "코드 가독성 > 코드 간결성"
- "외부 라이브러리 < 직접 구현 (단, 보안 관련은 예외)"

**문서 위치**: `.agent/rules/DECISION_PRINCIPLES.md`

### Level 2: 규칙 (Rules)

**특징**: 즉시 적용 가능한 구체적인 Do/Don't

**예시**:

- "TypeScript에서 `any` 타입 사용 금지"
- "모든 함수는 50줄 이하로 작성"
- "배포 전 최소 2명의 코드 리뷰 필수"

**문서 위치**: `.agent/rules/CODING_STANDARDS.md`, `GLOBAL_RULES.md` 등

---

## 🔑 규칙 작성 8대 원칙

### 1. 명확성 (Clarity)

- 해석의 여지가 없어야 함
- ❌ "가능한 한 짧게 작성하세요" (모호함)
- ✅ "함수는 50줄 이하로 작성하세요" (명확함)

### 2. 측정 가능성 (Measurability)

- 준수 여부를 자동화 도구로 검증 가능해야 함
- ❌ "코드를 깔끔하게 작성하세요" (측정 불가)
- ✅ "ESLint 에러 0개를 유지하세요" (측정 가능)

### 3. 정당성 (Justification)

- 모든 규칙은 "왜" 필요한지 이유를 명시
- 예: "any 사용 금지 → 타입 안전성 보장 → 런타임 에러 90% 감소"

### 4. 예외 명시 (Exception Handling)

- 규칙의 예외 상황을 명확히 정의
- 예: "함수 50줄 제한 (단, 타입 정의와 테스트 코드는 예외)"

### 5. 점진적 도입 (Gradual Adoption)

- 새로운 규칙은 즉시 적용이 아닌 유예 기간 제공
- 예: "2026-03-01부터 적용, 기존 코드는 리팩토링 시 수정"

### 6. 도구 지원 (Tooling Support)

- 가능한 한 Linter, Formatter 등으로 자동 검증
- 수동 확인이 필요한 규칙은 최소화

### 7. 실패 사례 포함 (Anti-Pattern)

- "하지 말아야 할 것"을 명시적으로 보여줌
- 좋은 예 vs 나쁜 예를 코드로 제시

### 8. 진화 가능성 (Evolvability)

- 규칙은 영구적이지 않음
- 비효율적인 규칙은 팀 합의 하에 수정/폐기 가능

---

## 📐 규칙 문서 표준 구조

모든 규칙 문서는 다음 구조를 따라야 합니다:

````markdown
# {아이콘} {문서명} (Document Name)

> **목적**: {이 규칙 문서가 해결하는 문제}  
> **적용 범위**: {어디에 적용되는지}  
> **최종 업데이트**: {날짜}  
> **책임자**: {유지보수 담당자/에이전트}

---

## 🎯 핵심 원칙 (Core Principles)

{이 규칙의 철학적 기반 2-3문장}

---

## 📋 규칙 목록 (Rules)

### 규칙 1: {규칙명}

**정의**: {규칙 설명}

**이유** (Why):

- {이 규칙이 필요한 이유}
- {이 규칙이 해결하는 문제}

**적용 방법** (How):

```language
// 좋은 예
```
````

```language
// 나쁜 예
```

**자동 검증** (Automation):

```json
// Linter 설정
```

**예외 사항** (Exceptions):

- {예외 상황 1}
- {예외 상황 2}

---

## ✅ 준수 체크리스트 (Compliance Checklist)

- [ ] 체크 항목 1
- [ ] 체크 항목 2

---

## 🚫 안티패턴 (Anti-Patterns)

### ❌ 안티패턴 1: {이름}

**문제**: {무엇이 잘못되었는지}
**영향**: {어떤 문제를 일으키는지}
**해결**: {올바른 방법}

---

## 📚 참고 자료 (References)

- [외부 문서/표준](URL)
- [도구/라이브러리](URL)

---

## 🔄 변경 이력 (Change Log)

### v1.1 (2026-02-01)

- 규칙 3 추가: {내용}
- 규칙 2 수정: {변경 사항}

### v1.0 (2026-01-01)

- 초기 버전 작성

````

---

## 🎨 규칙 문서 유형별 템플릿

### A. 코딩 표준 (Coding Standards)

**파일명**: `CODING_STANDARDS.md`

**필수 포함 내용**:
- 언어별 규칙 (TypeScript, Python 등)
- 네이밍 컨벤션
- 주석 작성 규칙
- 파일 구조
- 에러 처리
- 테스트 작성 기준

**템플릿**:
```markdown
# 💻 {프로젝트명} 코딩 표준

## 언어별 규칙

### TypeScript
#### 타입 시스템
**규칙**: `any` 타입 사용 금지

**이유**:
- TypeScript의 타입 안전성을 무력화함
- 런타임 에러 발생 가능성 증가

**적용 방법**:
```typescript
// ❌ 나쁜 예
function process(data: any) {
  return data.value * 2
}

// ✅ 좋은 예
interface Data {
  value: number
}

function process(data: Data): number {
  return data.value * 2
}
````

**자동 검증**:

```json
// .eslintrc.json
{
  "rules": {
    "@typescript-eslint/no-explicit-any": "error"
  }
}
```

**예외**:

- 서드파티 라이브러리 타입 정의가 없는 경우 (단, `unknown` 사용 권장)
- 마이그레이션 기간 (2026-03-01까지)

````

---

### B. 협업 규칙 (Collaboration Rules)

**파일명**: `GLOBAL_RULES.md` 또는 `COLLABORATION_PROTOCOL.md`

**필수 포함 내용**:
- 커뮤니케이션 프로토콜
- 코드 리뷰 프로세스
- 의사결정 방식
- 문서화 규칙
- 보고 양식

**템플릿**:
```markdown
# 🤝 {프로젝트명} 협업 규칙

## 제1원칙: 명시적 커뮤니케이션

**규칙**: 모든 중요 결정은 문서로 기록

**이유**:
- 암묵적 지식 방지
- 신규 팀원 온보딩 가속화
- 의사결정 추적 가능

**적용 방법**:
1. 중요 결정 시 `.agent/memory/DECISION_LOG.md`에 기록
2. 형식:
   ```markdown
   ## {날짜}: {결정 사항}

   **문제**: {무엇이 문제였는지}
   **대안**: {고려한 옵션들}
   **선택**: {최종 선택}
   **이유**: {선택 근거}
````

**체크리스트**:

- [ ] 기술 스택 변경 시 문서화
- [ ] 아키텍처 패턴 변경 시 문서화
- [ ] 보안 정책 변경 시 문서화

````

---

### C. 보안 정책 (Security Policy)

**파일명**: `SECURITY_POLICY.md`

**필수 포함 내용**:
- 인증/인가 규칙
- 데이터 암호화
- API Key 관리
- 취약점 보고 절차
- 침해 사고 대응

**템플릿**:
```markdown
# 🛡️ {프로젝트명} 보안 정책

## 규칙 1: API Key 격리

**정의**: 모든 API Key는 환경 변수로 관리하며, 절대 코드에 하드코딩하지 않음

**이유**:
- GitHub에 노출 시 즉시 악용 가능
- Key 회전 시 코드 변경 불필요

**적용 방법**:
```typescript
// ❌ 절대 금지
const apiKey = 'AIzaSyC...'

// ✅ 권장
const apiKey = process.env.GEMINI_API_KEY
if (!apiKey) {
  throw new Error('GEMINI_API_KEY is not set')
}
````

**자동 검증**:

```yaml
# .github/workflows/security.yml
- uses: trufflesecurity/trufflehog@main
```

**위반 시 조치**:

1. 즉시 해당 Key 회전
2. GitHub Commit History 전체 스캔
3. 사고 보고서 작성

````

---

### D. 아키텍처 원칙 (Architecture Principles)

**파일명**: `ARCHITECTURE_PRINCIPLES.md`

**필수 포함 내용**:
- 설계 패턴
- 모듈 간 의존성 규칙
- 데이터 흐름
- 확장성 전략

**템플릿**:
```markdown
# 🏛️ {프로젝트명} 아키텍처 원칙

## 원칙 1: 관심사의 분리 (Separation of Concerns)

**정의**: 각 계층은 단일 책임만 가지며, 상위 계층에 의존하지 않음

**구조**:
````

Presentation Layer (UI)
↓
Business Logic Layer (Services)
↓
Data Access Layer (Repositories)
↓
Database

````

**규칙**:
- UI 컴포넌트는 직접 DB에 접근하지 않음
- Business Logic은 UI 프레임워크에 의존하지 않음

**위반 예**:
```typescript
// ❌ UI에서 직접 DB 접근
function UserProfile() {
  const user = supabase.from('users').select('*').single()
  // ...
}

// ✅ Service Layer를 통한 접근
function UserProfile() {
  const user = await userService.getCurrentUser()
  // ...
}
````

````

---

## 🧪 규칙 검증 체크리스트

새로운 규칙을 추가하기 전에 다음을 확인하세요:

### 필요성 (Necessity)
- [ ] 이 규칙이 없으면 실제 문제가 발생하는가?
- [ ] 과거에 유사한 문제가 3회 이상 발생했는가?
- [ ] 팀원 간 혼란이나 불일치가 있었는가?

### 명확성 (Clarity)
- [ ] 규칙이 한 문장으로 설명 가능한가?
- [ ] 좋은 예와 나쁜 예가 명확하게 제시되었는가?
- [ ] 예외 상황이 구체적으로 명시되었는가?

### 실행 가능성 (Actionability)
- [ ] 팀원이 이 규칙을 즉시 적용할 수 있는가?
- [ ] 자동화 도구로 검증 가능한가?
- [ ] 준수 여부를 명확히 판단할 수 있는가?

### 균형성 (Balance)
- [ ] 생산성을 과도하게 저해하지 않는가?
- [ ] 규칙이 너무 엄격하거나 너무 느슨하지 않은가?
- [ ] 팀의 80% 이상이 동의하는가?

### 진화 가능성 (Evolvability)
- [ ] 기술 변화에 따라 업데이트 가능한가?
- [ ] 폐기 기준이 명확한가?
- [ ] 버전 관리가 되고 있는가?

---

## 🔄 규칙 생명주기 관리

### 1. 제안 (Proposal)
```markdown
## [제안] 새로운 규칙: {규칙명}

**제안자**: {이름/에이전트}
**제안일**: {날짜}

**문제**:
- {해결하려는 문제}

**제안 규칙**:
- {구체적인 규칙 내용}

**예상 영향**:
- 긍정: {장점}
- 부정: {단점}

**피드백 기한**: {날짜}
````

### 2. 검토 (Review)

- 팀원/에이전트 피드백 수집 (최소 3일)
- 반대 의견에 대한 조정
- 80% 이상 동의 시 승인

### 3. 시범 적용 (Pilot)

- 1~2주 동안 일부 모듈에만 적용
- 문제점 수집 및 개선

### 4. 전체 적용 (Adoption)

```markdown
## 📢 새로운 규칙 공지

**규칙명**: {규칙명}  
**적용일**: {날짜}  
**유예 기간**: {기간}

**내용**:

- {규칙 요약}

**체크리스트**:

- [ ] `.eslintrc` 업데이트
- [ ] CI/CD 파이프라인에 검증 추가
- [ ] 기존 코드 마이그레이션 계획 수립
```

### 5. 모니터링 (Monitoring)

- 월 1회 준수율 확인
- 분기 1회 유효성 재평가

### 6. 폐기 (Deprecation)

```markdown
## ⚠️ 규칙 폐기 예정

**규칙명**: {규칙명}  
**폐기 사유**: {이유}  
**폐기 예정일**: {날짜} (3개월 유예)

**대체 규칙**:

- {새로운 규칙 또는 권장 사항}
```

---

## 💡 규칙 작성 Best Practices

### DO ✅

1. **구체적인 숫자 사용**: "최대한 짧게" (X) → "50줄 이하" (O)
2. **자동화 도구 제시**: ESLint, Prettier 설정 포함
3. **이유 명시**: 모든 규칙에 "왜" 필요한지 설명
4. **예외 명시**: 100% 적용이 불가능한 경우 예외 상황 정의
5. **변경 이력 기록**: 규칙 수정 시 날짜와 이유 기록

### DON'T ❌

1. **주관적 표현**: "좋은 코드", "깔끔한 디자인" 등
2. **모호한 기준**: "가능한 한", "보통", "대략"
3. **과도한 규칙**: 하루에 10개 이상 새 규칙 추가 금지
4. **검증 불가능**: 자동화할 수 없고 수동 확인도 어려운 규칙
5. **일방적 강제**: 팀 합의 없이 규칙 추가

---

## 📊 규칙 문서 품질 평가

### 자가 평가 체크리스트 (100점 만점)

#### 구조 및 형식 (20점)

- [ ] (5점) 표준 템플릿 준수
- [ ] (5점) 섹션 누락 없음
- [ ] (5점) 마크다운 문법 정확
- [ ] (5점) 목차 및 네비게이션 제공

#### 내용 품질 (40점)

- [ ] (10점) 모든 규칙에 "이유" 명시
- [ ] (10점) 좋은 예/나쁜 예 코드 포함
- [ ] (10점) 자동화 도구 설정 포함
- [ ] (10점) 예외 사항 명시

#### 실행 가능성 (30점)

- [ ] (10점) 즉시 적용 가능
- [ ] (10점) 측정/검증 가능
- [ ] (10점) 명확하고 모호하지 않음

#### 유지보수성 (10점)

- [ ] (5점) 변경 이력 기록
- [ ] (5점) 책임자 명시

**합계**: \_\_/100점  
**통과 기준**: 80점 이상

---

## 🎓 실전 예시: "한국어 우선" 규칙 생성

### Step 1: 문제 정의

```
현상: 코드 주석이 영어/한국어 혼용되어 가독성 저하
영향: 신규 팀원 온보딩 시간 증가, 문서 검색 어려움
```

### Step 2: 규칙 초안 작성

```markdown
## 규칙: 한국어 우선 원칙

**정의**: 모든 대화, 주석, 문서는 한국어로 작성

**이유**:

- 팀원 모두 한국어 네이티브
- 영어 번역 시간 절약
- 미묘한 의도 전달 가능

**예외**:

- 코드 자체 (변수명, 함수명)
- Git 커밋 메시지
- 기술 용어 (API, REST, JSON 등)
```

### Step 3: 예시 추가

````markdown
**적용 방법**:

```typescript
// ❌ 나쁜 예: 영어 주석
// Fetch user data from database
const user = await db.users.findOne();

// ✅ 좋은 예: 한국어 주석
// 데이터베이스에서 사용자 정보 조회
const user = await db.users.findOne();
```
````

````

### Step 4: 자동화 검토
```markdown
**자동 검증**:
- 현재는 수동 검증 (코드 리뷰 시 확인)
- 향후 개선: VSCode Extension으로 주석 언어 검사
````

### Step 5: 팀 피드백

```
피드백 1: JSDoc은 어떻게?
→ 업데이트: JSDoc은 영어 허용 (TypeScript 도구 호환성)

피드백 2: 기존 코드는?
→ 업데이트: 유예 기간 3개월, 이후 점진적 마이그레이션
```

### Step 6: 최종 버전

````markdown
## 규칙 1: 한국어 우선 원칙

**정의**: 모든 대화, 코드 주석, 문서는 한국어로 작성

**이유**:

- 팀원 모두 한국어 네이티브 → 의사소통 효율 증가
- 영어 번역 오버헤드 제거 → 개발 속도 10% 향상 (측정 결과)

**적용 방법**:

```typescript
// ❌ 나쁜 예
// Fetch user data from database
const user = await db.users.findOne();

// ✅ 좋은 예
// 데이터베이스에서 사용자 정보 조회
const user = await db.users.findOne();
```
````

**예외**:

- 코드 자체 (변수명 `userName`, 함수명 `fetchUser` 등)
- Git 커밋 메시지 (Conventional Commits 표준 준수)
- JSDoc/Docstring (TypeScript 도구 호환성)
- 기술 용어 (API, REST, JSON 등은 영어 그대로)

**유예 기간**: 2026-05-01까지 (기존 코드는 점진적 마이그레이션)

**검증 방법**:

- Pull Request 시 리뷰어가 주석 언어 확인
- 체크리스트: "[ ] 한국어 주석 원칙 준수"

```

---

## 🚀 규칙 문서 배포 체크리스트

새로운 규칙 문서를 배포하기 전에:

- [ ] 표준 템플릿 준수 확인
- [ ] 품질 평가 80점 이상
- [ ] 팀원 80% 이상 동의 확보
- [ ] 자동화 도구 설정 완료 (가능한 경우)
- [ ] README.md에 규칙 문서 링크 추가
- [ ] Git 커밋 메시지: `docs(rules): Add {규칙명}`
- [ ] 팀 공지 (Slack, Discord 등)
- [ ] 온보딩 문서에 반영

---

**이 가이드를 따라 생성된 규칙 문서는 명확하고, 실행 가능하며, 진화 가능합니다.** 📜
```
